<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ken Friis Larsen, Maya Saietz" />
  <title>Exercise Set 0, Haskell</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">body {
margin-top: 1.0em;
background-color: white;
 font-size: 13pt;
color: black;
width: 90%;
margin: 0 auto;
}
html {
font-family: "Source Serif Pro", Georgia, "Times New Roman", serif;
}
h2, h3, h4, h5, h6 {
font-family: "Oswald", Helvetica, Arial, sans-serif;
font-weight: 400;
color: #313131;
letter-spacing: -.025rem;
}
code {
font-family: "Source Code Pro", Menlo, monospace;
 background-color: #F0F3F3;
}
pre {
background-color: #F0F3F3;
padding: 6px;
word-wrap: break-word;
white-space: pre-wrap;
font-family: "Source Code Pro", Menlo, monospace;
border: 1px solid silver;
}
h1.title {
font-family: 'Dancing Script', sans-serif;
text-align: center; font-size: 3.8em; color: black; margin-bottom: 3px;
}
h1 .small { font-size: 0.4em; }
h1 a { text-decoration: none }
h2 { font-size: 1.5em; color: black; }
p.author { font-size: 1em; text-align: center; color: black; }
p.date { font-size: 1em; text-align: center; color: black; }
a { color: black; }
.description { font-size: 1.2em; margin-bottom: 30px; margin-top: 30px; font-style: italic;}
.download { float: right; }

hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.footer { text-align:center; padding-top:30px; font-style: italic; }
table { border-collapse: collapse }
td { border: 1px solid black }
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Exercise Set 0, Haskell</h1>
<p class="author"><a href="http://diku.dk/~kflarsen">Ken Friis Larsen</a>, Maya Saietz</p>
<p class="date">September, 2018</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#touring-haskell">Touring Haskell</a></li>
<li><a href="#morse-code">Morse Code</a></li>
<li><a href="#tic-tac-toe">Tic-Tac-Toe</a></li>
<li><a href="#type-classes">Type classes</a></li>
</ul>
</nav>
<h2 id="touring-haskell">Touring Haskell</h2>
<ul>
<li><p>Finish the declaration of the function <code>move</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Pos</span> <span class="fu">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Direction</span> <span class="fu">=</span> <span class="dt">North</span> <span class="fu">|</span> <span class="dt">South</span> <span class="fu">|</span> <span class="dt">East</span> <span class="fu">|</span> <span class="dt">West</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">move ::</span> <span class="dt">Direction</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">move <span class="dt">North</span> (x,y) <span class="fu">=</span> (x, y<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">move <span class="dt">West</span>  (x,y) <span class="fu">=</span> (x<span class="fu">-</span><span class="dv">1</span>, y)</a></code></pre></div></li>
<li><p>Declare a function <code>moves</code> with the type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">moves ::</span> [<span class="dt">Direction</span>] <span class="ot">-&gt;</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span> </a></code></pre></div></li>
<li><p>Declare a function for multiplying natural numbers, using the follow data type declaration:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Ord</span>) </a></code></pre></div>
<p>(Hint: Start with addition)</p></li>
<li><p>Declare functions <code>nat2int</code> and <code>int2nat</code> to go from natural numbers (the previous given data type) to Haskell integers and back.</p></li>
<li><p>Given the data type for representing binary search trees with integers stored in the nodes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- Every element in the left subtree is &lt;= node value.</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Declare a function, <code>insert</code>, that takes an integer, <code>n</code>, and a binary search tree and returns a new binary search tree with <code>n</code> inserted.</p></li>
<li><p>Change the declaration of <code>Tree</code> so that it is polymorphic in the data stored in the nodes. What happens to the type of the function <code>insert</code>?</p></li>
</ul>
<!--
* Extend the type `Expr` (and the function `value`) with operations for
  multiplication, division, and subtraction 
 
    ~~~~ {.haskell}
    data Expr = Con Int
              | Add Expr Expr
         deriving (Eq, Show, Read, Ord) 

    value :: Expr -> Int
    value (Con n) = n
    value (Add x y) = value x + value y 
    ~~~~
    
    What happens when you divide by 0? What are the maximum and minimum
    numeric values that an `Expr` can evaluate to?

* Write a pretty printer function for `Expr` that inserts as few
  parentheses as you can manage.
-->
<h2 id="morse-code">Morse Code</h2>
<p>[Rephrased from <a href="http://www.rubyquiz.com/quiz121.html">ruby quiz #121</a>]</p>
<p>Morse code is a way to encode telegraphic messages in a series of long and short sounds or visual signals. During transmission, pauses are used to group letters and words, but in written form the code can be ambiguous.</p>
<p>For example, using the typical dot (<code>.</code>) and dash (<code>-</code>) for a written representation of the code, the word <code>...---..-....-</code> in Morse code could be an encoding of the names Sofia or Eugenia depending on where you break up the letters:</p>
<pre><code>  ...|---|..-.|..|.-    Sofia
  .|..-|--.|.|-.|..|.-  Eugenia</code></pre>
<p>We will only focus on the alphabet for this quiz to keep things simple. Here are the encodings for each letter:</p>
<pre><code>  A .-            N -.
  B -...          O ---
  C -.-.          P .--.
  D -..           Q --.-
  E .             R .-.
  F ..-.          S ...
  G --.           T -
  H ....          U ..-
  I ..            V ...-
  J .---          W .--
  K -.-           X -..-
  L .-..          Y -.--
  M --            Z --..</code></pre>
<ul>
<li><p>Declare a function, <code>encode</code>, that takes a string (of letters) as argument and translate it to morse code (as a string).</p></li>
<li><p>Declare a function, <code>decode</code>, that takes a string encoded in morse code as argument and return a list of all possible translations.</p></li>
</ul>
<h2 id="tic-tac-toe">Tic-Tac-Toe</h2>
<p>These exercises assume that you have downloaded the file <code>TicTacToe.hs</code>, which you can find on Absalon under <em>Files</em>.</p>
<ul>
<li><p>Define the undefined values <code>startState</code>, <code>makeMove</code>, <code>validMove</code>, <code>allValidMoves</code>, and <code>makeTree</code>.</p>
<p>Define one of them at a time, and make sure that your Haskell file still compiles after each change.</p></li>
<li><p>Make sure that you understand the <code>allNodes</code> function, especially what the functions <code>concatMap</code>, <code>snd</code>, and <code>.</code> (dot) does. Try to write each of these functions yourself.</p></li>
<li><p>Observe the difference in running time of</p>
<pre><code>  length (allNodes (makeTree startState))    -- should return 986410</code></pre>
<p>and</p>
<pre><code>  take 3 (allNodes (makeTree startState))</code></pre>
<p>Can you explain that?</p></li>
<li><p>Watch <a href="http://haskelllive.com/episode-1-the-chess-board/">Haskell Live episode 1</a>, and make <code>showBoard</code> and <code>readBoard</code> functions for tic-tac-toe boards in a similar style as Rein Henrichs (the Haskell Live creator) does for chess boards.</p></li>
<li><p>Implement the <a href="http://en.wikipedia.org/wiki/Minimax">minimax</a> algorithm for finding an optimal move in a given game state.</p></li>
</ul>
<h2 id="type-classes">Type classes</h2>
<p>Following is an interface for types that can be said to have a size.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Sizeable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  size ::</span> t <span class="ot">-&gt;</span> <span class="dt">Int</span></a></code></pre></div>
<p>We say that a primitive type like <code>Int</code> have size one:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Sizeable</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  size _ <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>When we want to ascribe a size to aggregate types like lists, we need to take a decision: Should the size of a list be just the length of the list, or is the size of a list the sum of the size of the elements plus the length of the list (plus one). Complete the following two instance declarations (one for each interpretation of what sizeable means)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Sizeable</span> [a] <span class="kw">where</span> </a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">...</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  </a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Sizeable</span> a <span class="ot">=&gt;</span> <span class="dt">Sizeable</span> [a] <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="fu">...</span></a></code></pre></div>
<p><strong>Note:</strong> You cannot have both instance declarations active at the same time.</p>
<p>Make pairs, <code>String</code>, and <code>Tree</code> sizeable.</p>
<!-- Monads -->
<!-- ------ -->
<!-- * Finish the declaration: -->
<!--     ~~~~ {.haskell} -->
<!--     data List a = Nil | Cons a (List a) -->
<!--     instance Monad List where -->
<!--           ... -->
<!--     ~~~~ -->
<!--     **Hint:** start by thinking about how the normal list is declared as a monad: -->
<!--     ~~~~ {.haskell}       -->
<!--     instance Monad [] where -->
<!--           ... -->
<!--     ~~~~ -->
<!--     **Hint 2:** Start my defining the functions `concat` and `map` for the `List` type and use these in your declarations. -->
<!-- * Rewrite the function `findAssoc` -->
<!--     ~~~~ {.haskell} -->
<!--     type Assoc a = [(String, a)] -->
<!--     findAssoc :: String -> Assoc a -> a -->
<!--     findAssoc key assoc = head bindings -->
<!--         where bindings = [val| (k,val) <- assoc, k == key] -->
<!--     ~~~~ -->
<!--     so that it returns `Nothing` rather than producing an error if no binding is found for a key. -->
<!--     Use the re-written `findAssoc` and the `do`-notation to write a function that takes an association list and two keys as arguments, looks up the keys, add their values, and return the result. -->
</body>
</html>
